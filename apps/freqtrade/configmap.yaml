apiVersion: v1
kind: ConfigMap
metadata:
  name: freqtrade-config
  namespace: freqtrade
data:
  config.json: |
    {
        "max_open_trades": 10,
        "stake_currency": "USDT",
        "stake_amount": "unlimited",
        "tradable_balance_ratio": 0.99,
        "fiat_display_currency": "EUR",
        "dry_run": true,
        "dry_run_wallet": 1000,
        "cancel_open_orders_on_exit": false,
        "trading_mode": "spot",
        "margin_mode": "",
        "unfilledtimeout": {
            "entry": 10,
            "exit": 10,
            "exit_timeout_count": 0,
            "unit": "minutes"
        },
        "entry_pricing": {
            "price_side": "same",
            "use_order_book": true,
            "order_book_top": 1,
            "price_last_balance": 0.0,
            "check_depth_of_market": {
                "enabled": false,
                "bids_to_ask_delta": 1
            }
        },
        "exit_pricing":{
            "price_side": "same",
            "use_order_book": true,
            "order_book_top": 1
        },
        "strategy": "NostalgiaForInfinityX",
        "exchange": {
            "name": "binance",
            "ccxt_config": {},
            "ccxt_async_config": {},
            "pair_whitelist": [
              "BTC/USDT", 
              "ETH/USDT", 
              "SOL/USDT", 
              "USDC/USDT", 
              "XRP/USDT", 
              "TON/USDT", 
              "DOGE/USDT", 
              "ADA/USDT", 
              "TRX/USDT", 
              "WBTC/USDT", 
              "AVAX/USDT", 
              "SHIB/USDT", 
              "LINK/USDT", 
              "DOT/USDT", 
              "LTC/USDT", 
              "UNI/USDT", 
              "NEAR/USDT", 
              "MATIC/USDT", 
              "ICP/USDT"
            ],
            "pair_blacklist": [
                "BNB/.*"
            ]
        },
        "pairlists": [
           {
           "method": "StaticPairList",
           "pairs": [
              "BTC/USDT", 
              "ETH/USDT", 
              "SOL/USDT", 
              "USDC/USDT", 
              "XRP/USDT", 
              "TON/USDT", 
              "DOGE/USDT", 
              "ADA/USDT", 
              "TRX/USDT", 
              "WBTC/USDT", 
              "AVAX/USDT", 
              "SHIB/USDT", 
              "LINK/USDT", 
              "DOT/USDT", 
              "LTC/USDT", 
              "UNI/USDT", 
              "NEAR/USDT", 
              "MATIC/USDT", 
              "ICP/USDT"
           ]
           
           }
        ],
        "telegram": {
            "enabled": true,
        },
        "api_server": {
            "enabled": true,
            "listen_ip_address": "0.0.0.0",
            "listen_port": 8080,
            "verbosity": "error",
            "enable_openapi": false,
            "CORS_origins": [],
            "username": "",
            "password": ""
        },
        "bot_name": "freqtrade",
        "initial_state": "running",
        "force_entry_enable": false,
        "internals": {
            "process_throttle_secs": 5
        }
    }

# ---
# apiVersion: v1
# kind: ConfigMap
# metadata:
#   name: strategy
#   namespace: freqtrade
# data:
#   BigTrader.py: |
#     from datetime import datetime, timedelta
#     import talib.abstract as ta
#     import pandas_ta as pta
#     from freqtrade.persistence import Trade
#     from freqtrade.strategy.interface import IStrategy
#     from pandas import DataFrame
#     from freqtrade.strategy import DecimalParameter, IntParameter
#     from functools import reduce
#     import warnings

#     warnings.simplefilter(action="ignore", category=RuntimeWarning)
#     TMP_HOLD120 = []


#     class E0V1E(IStrategy):
#         minimal_roi = {
#             "0": 1
#         }
#         timeframe = '5m'
#         process_only_new_candles = True
#         startup_candle_count = 240
#         order_types = {
#             'entry': 'market',
#             'exit': 'market',
#             'emergency_exit': 'market',
#             'force_entry': 'market',
#             'force_exit': "market",
#             'stoploss': 'market',
#             'stoploss_on_exchange': False,
#             'stoploss_on_exchange_interval': 60,
#             'stoploss_on_exchange_market_ratio': 0.99
#         }

#         stoploss = -0.25
#         trailing_stop = True
#         trailing_stop_positive = 0.003
#         trailing_stop_positive_offset = 0.03
#         trailing_only_offset_is_reached = True

#         is_optimize_32 = True
#         buy_rsi_fast_32 = IntParameter(20, 70, default=30, space='buy', optimize=is_optimize_32)
#         buy_rsi_32 = IntParameter(15, 50, default=24, space='buy', optimize=is_optimize_32)
#         buy_sma15_32 = DecimalParameter(0.900, 1, default=0.96, decimals=3, space='buy', optimize=is_optimize_32)
#         buy_cti_32 = DecimalParameter(-1, 1, default=0.69, decimals=2, space='buy', optimize=is_optimize_32)

#         sell_fastx = IntParameter(50, 100, default=84, space='sell', optimize=True)

#         cci_opt = True
#         sell_loss_cci = IntParameter(low=0, high=600, default=80, space='sell', optimize=cci_opt)
#         sell_loss_cci_profit = DecimalParameter(-0.15, 0, default=-0.1, decimals=2, space='sell', optimize=cci_opt)

#         def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
#             # buy_1 indicators
#             dataframe['sma_15'] = ta.SMA(dataframe, timeperiod=15)
#             dataframe['cti'] = pta.cti(dataframe["close"], length=20)
#             dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14)
#             dataframe['rsi_fast'] = ta.RSI(dataframe, timeperiod=4)
#             dataframe['rsi_slow'] = ta.RSI(dataframe, timeperiod=20)
#             # profit sell indicators
#             stoch_fast = ta.STOCHF(dataframe, 5, 3, 0, 3, 0)
#             dataframe['fastk'] = stoch_fast['fastk']

#             dataframe['cci'] = ta.CCI(dataframe, timeperiod=20)

#             dataframe['ma120'] = ta.MA(dataframe, timeperiod=120)

#             return dataframe

#         def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
#             conditions = []
#             dataframe.loc[:, 'enter_tag'] = ''
#             buy_1 = (
#                     (dataframe['rsi_slow'] < dataframe['rsi_slow'].shift(1)) &
#                     (dataframe['rsi_fast'] < self.buy_rsi_fast_32.value) &
#                     (dataframe['rsi'] > self.buy_rsi_32.value) &
#                     (dataframe['close'] < dataframe['sma_15'] * self.buy_sma15_32.value) &
#                     (dataframe['cti'] < self.buy_cti_32.value)
#             )
#             conditions.append(buy_1)
#             dataframe.loc[buy_1, 'enter_tag'] += 'buy_1'
            
#             if conditions:
#                 dataframe.loc[
#                     reduce(lambda x, y: x | y, conditions),
#                     'enter_long'] = 1
#             return dataframe

#         def custom_exit(self, pair: str, trade: 'Trade', current_time: 'datetime', current_rate: float,
#                         current_profit: float, **kwargs):
#             dataframe, _ = self.dp.get_analyzed_dataframe(pair=pair, timeframe=self.timeframe)
#             current_candle = dataframe.iloc[-1].squeeze()

#             if trade.open_rate > current_candle["ma120"]:
#                 if trade.id not in TMP_HOLD120:
#                     TMP_HOLD120.append(trade.id)

#             if current_profit > 0:
#                 if current_candle["fastk"] > self.sell_fastx.value:
#                     remove_pubid(trade.id)
#                     return "fastk_profit_sell"

#             if current_profit > self.sell_loss_cci_profit.value:
#                 if current_candle["cci"] > self.sell_loss_cci.value:
#                     remove_pubid(trade.id)
#                     return "cci_loss_sell"

#             if trade.id in TMP_HOLD120 and current_candle["open"] < current_candle["ma120"]:
#                 TMP_HOLD120.remove(trade.id)
#                 return "ma120_sell"

#             return None

#         def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
#             dataframe.loc[:, ['exit_long', 'exit_tag']] = (0, 'long_out')
#             return dataframe
